[{"categories":["tools"],"content":"本文用于记录如何搭建适合自己的高效工作环境，适用于 MacBook。 ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:0:0","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"Oh, My ZSH~ zsh 是 Linux 和 MacOS 常用的命令解释器，相比于默认的 Bash，Zsh 有更多的自定义选项，并支持扩展。因此 zsh 可以实现更强大的命令补全，命令高亮等一系列酷炫功能。 不过配置 zsh 是个比较麻烦的事情，于是有位小哥 Robby Russell 在 github 上分享了他的 zsh 配置（ohmyzsh）。他的默认主题就很对我的胃口。 ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:1:0","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"安装 Oh, My ZSH 如果有条件翻墙，直接执行下面的命令即可 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 如果翻不了墙，可以使用国内用户 fork 的仓库，具体操作步骤如下。 打开 gitee 网站 搜索 ohmyzsh，挑一个顺眼的仓库 找到文件 tools/install.sh 点击页面上的原始数据按钮 将浏览器地址栏的 URL 复制，执行如下命令安装 # 假设复制的 URL 为 https://gitee.com/oldsyang/ohmyzsh/raw/master/tools/install.sh sh -c \"$(curl -fsSL https://gitee.com/oldsyang/ohmyzsh/raw/master/tools/install.sh)\" ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:1:1","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"更换主题 如果觉得 myzsh 的默认主题不符合你的审美，那么可以修改 ~/.zshrc 中的配置项 ZSH_THEME，可用的主题详见vscode themes ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:1:2","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"启用插件 通过将插件的名称添加到 ~/.zshrc 文件中的 plugins 数组来启用插件。比如，想要启用 git 和 vscode 插件，只需要如下设置(注意： 插件之间用空格隔开，不要使用逗号) plugins=(git vscode) 插件列表详见plugins ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:1:3","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"VSCode ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:2:0","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"安装 VSCode 直接去官网（vscode）下载安装即可，如果发现下载缓慢，可以参考这篇文章 ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:2:1","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"设置命令行启动 VSCode 按下 shift+cmd+P打开命令面板，找到 Shell Command: Install 'code' command in PATH，按下回车键。 然后就可以在终端键入 code . 命令打开 VsCode，并且打开当前文件夹。 当你要接手一个新项目的时候，下载代码、打开 IDE 将会变得非常丝滑 git clone https://github.com/xxxx/repo.git cd ./repo code . ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:2:2","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["tools"],"content":"常用扩展 通用 简体中文语言扩展 GitLens Git History Markdown All in One Makefile Tools Local History Project Manager Todo Tree protobuf Protobuf support vscode-proto3 Better TOML YAML Golang Go Rust Rust Syntax rust-analyzer Rust Test Lens crates ","date":"2023-06-05","objectID":"/fufeng/build_your_working_env/:2:3","tags":["vscode","shell"],"title":"搭建自己的工作环境","uri":"/fufeng/build_your_working_env/"},{"categories":["DevOps"],"content":"本篇文章将介绍如何在 ubuntu 系统上安装接近生产环境的 Kubernetes。 ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:0:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"安装 Docker sudo apt install -y docker.io sudo service docker start #启动docker服务 sudo usermod -aG docker ${USER} #当前用户加入docker组 # 将 cgroup 的驱动程序改成 systemd ，然后重启 Docker 的守护进程 cat \u003c\u003cEOF | sudo tee /etc/docker/daemon.json { \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"storage-driver\": \"overlay2\" } EOF sudo systemctl enable docker sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:1:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"修改 iptables 配置 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward=1 # better than modify /etc/sysctl.conf EOF sudo sysctl --system ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:2:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"[可选]关闭 Linux 的 swap 分区 sudo swapoff -a sudo sed -ri '/\\sswap\\s/s/^#?/#/' /etc/fstab ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:3:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"安装 kubeadm sudo apt install -y apt-transport-https ca-certificates curl curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - cat \u003c\u003cEOF | sudo tee /etc/apt/sources.list.d/kubernetes.list deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF sudo apt update sudo apt install -y kubeadm=1.23.3-00 kubelet=1.23.3-00 kubectl=1.23.3-00 # 锁定版本 sudo apt-mark hold kubeadm kubelet kubectl ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:4:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"[可选]下载 Kubernetes 组件镜像 将下面的脚本拷贝进文件，然后执行文件即可 #!/bin/bash repo=registry.aliyuncs.com/google_containers for name in `kubeadm config images list --kubernetes-version v1.23.3`; do src_name=${name#k8s.gcr.io/} src_name=${src_name#coredns/} docker pull $repo/$src_name docker tag $repo/$src_name $name docker rmi $repo/$src_name done ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:5:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"安装 Master 节点 sudo kubeadm init \\ --pod-network-cidr=10.10.0.0/16 \\ --image-repository registry.aliyuncs.com/google_containers \\ # 如果已经提前下载了 Kubernetes 组件镜像，可以忽略这个参数 --apiserver-advertise-address=192.168.10.210 \\ # 这里需要替换成本机的 IP --kubernetes-version=v1.23.3 kubeadm init 成功之后，按照在终端上看到的提示操作即可 To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 另外还有一个很重要的“kubeadm join”提示，其他节点要加入集群必须要用指令里的 token 和 ca 证书，所以这条命令务必拷贝后保存好 Then you can join any number of worker nodes by running the following on each as root: kubeadm join XXX.XXX.XXX.XXX:XXX --token XXXXXX.XXXXXXXXXXXXXXXXXX \\ --discovery-token-ca-cert-hash sha256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 如果没有保存，也没有关系🐶，可以使用下面的命令重新获取到 sudo kubeadm token create --print-join-command ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:6:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"安装 Flannel 网络插件 kubectl apply -f kube-flannel.yml kube-flannel.yml 的内容如下 apiVersion: v1 kind: Namespace metadata: labels: k8s-app: flannel pod-security.kubernetes.io/enforce: privileged name: kube-flannel --- apiVersion: v1 kind: ServiceAccount metadata: labels: k8s-app: flannel name: flannel namespace: kube-flannel --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: labels: k8s-app: flannel name: flannel rules: - apiGroups: - \"\" resources: - pods verbs: - get - apiGroups: - \"\" resources: - nodes verbs: - get - list - watch - apiGroups: - \"\" resources: - nodes/status verbs: - patch - apiGroups: - networking.k8s.io resources: - clustercidrs verbs: - list - watch --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: labels: k8s-app: flannel name: flannel roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannel subjects: - kind: ServiceAccount name: flannel namespace: kube-flannel --- apiVersion: v1 data: cni-conf.json: | { \"name\": \"cbr0\", \"cniVersion\": \"0.3.1\", \"plugins\": [ { \"type\": \"flannel\", \"delegate\": { \"hairpinMode\": true, \"isDefaultGateway\": true } }, { \"type\": \"portmap\", \"capabilities\": { \"portMappings\": true } } ] } net-conf.json: | { \"Network\": \"10.10.0.0/16\", \"Backend\": { \"Type\": \"vxlan\" } } kind: ConfigMap metadata: labels: app: flannel k8s-app: flannel tier: node name: kube-flannel-cfg namespace: kube-flannel --- apiVersion: apps/v1 kind: DaemonSet metadata: labels: app: flannel k8s-app: flannel tier: node name: kube-flannel-ds namespace: kube-flannel spec: selector: matchLabels: app: flannel k8s-app: flannel template: metadata: labels: app: flannel k8s-app: flannel tier: node spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/os operator: In values: - linux containers: - args: - --ip-masq - --kube-subnet-mgr command: - /opt/bin/flanneld env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: EVENT_QUEUE_DEPTH value: \"5000\" image: docker.io/flannel/flannel:v0.22.0 name: kube-flannel resources: requests: cpu: 100m memory: 50Mi securityContext: capabilities: add: - NET_ADMIN - NET_RAW privileged: false volumeMounts: - mountPath: /run/flannel name: run - mountPath: /etc/kube-flannel/ name: flannel-cfg - mountPath: /run/xtables.lock name: xtables-lock hostNetwork: true initContainers: - args: - -f - /flannel - /opt/cni/bin/flannel command: - cp image: docker.io/flannel/flannel-cni-plugin:v1.1.2 name: install-cni-plugin volumeMounts: - mountPath: /opt/cni/bin name: cni-plugin - args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist command: - cp image: docker.io/flannel/flannel:v0.22.0 name: install-cni volumeMounts: - mountPath: /etc/cni/net.d name: cni - mountPath: /etc/kube-flannel/ name: flannel-cfg priorityClassName: system-node-critical serviceAccountName: flannel tolerations: - effect: NoSchedule operator: Exists volumes: - hostPath: path: /run/flannel name: run - hostPath: path: /opt/cni/bin name: cni-plugin - hostPath: path: /etc/cni/net.d name: cni - configMap: name: kube-flannel-cfg name: flannel-cfg - hostPath: path: /run/xtables.lock type: FileOrCreate name: xtables-lock ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:7:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"安装 Worker 节点 sodu kubeadm join XXX.XXX.XXX.XXX:XXX --token XXXXXX.XXXXXXXXXXXXXXXXXX \\ --discovery-token-ca-cert-hash sha256:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX ","date":"2023-06-03","objectID":"/fufeng/install-k8s-on-ubuntu/:8:0","tags":["K8S","Kubernetes"],"title":"在 ubuntu 系统安装 K8S","uri":"/fufeng/install-k8s-on-ubuntu/"},{"categories":["DevOps"],"content":"本篇文章将介绍如何在 Mac 上使用 minikube 搭建单机版的 Kubernetes。 ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:0:0","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"安装步骤 ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:1:0","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"安装 Docker 安装 docker 主要是用于提供容器引擎。直接下载安装即可。 下载地址 ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:1:1","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"安装 Kubectl 推荐使用 home brew 安装 brew install kubectl 可以使用下面的命令查看是否已经安装完毕 kubectl version --client ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:1:2","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"安装 Minikube 依然推荐使用 home brew 安装 brew install minikube 可以使用下面的命令查看是否已经安装完毕 minikube -h 如果能输出一下信息则安装成功 minikube provisions and manages local Kubernetes clusters optimized for development workflows. Basic Commands: start Starts a local Kubernetes cluster status Gets the status of a local Kubernetes cluster stop Stops a running local Kubernetes cluster delete Deletes a local Kubernetes cluster dashboard 访问在 minikube 集群中运行的 kubernetes dashboard pause pause Kubernetes unpause 恢复 Kubernetes Images Commands: docker-env Provides instructions to point your terminal's docker-cli to the Docker Engine inside minikube. (Useful for building docker images directly inside minikube) podman-env 配置环境以使用 minikube's Podman service cache Manage cache for images image Manage images Configuration and Management Commands: addons Enable or disable a minikube addon config Modify persistent configuration values profile Get or list the current profiles (clusters) update-context Update kubeconfig in case of an IP or port change Networking and Connectivity Commands: service Returns a URL to connect to a service tunnel 连接到 LoadBalancer 服务 Advanced Commands: mount 将指定的目录挂载到 minikube ssh Log into the minikube environment (for debugging) kubectl Run a kubectl binary matching the cluster version node 添加，删除或者列出其他的节点 cp 将指定的文件复制到 minikube Troubleshooting Commands: ssh-key Retrieve the ssh identity key path of the specified node ssh-host Retrieve the ssh host key of the specified node ip Retrieves the IP address of the specified node logs Returns logs to debug a local Kubernetes cluster update-check 打印当前和最新版本版本 version 打印 minikube 版本 options 显示全局命令行选项列表 (应用于所有命令)。 Other Commands: completion Generate command completion for a shell license Outputs the licenses of dependencies to a directory Use \"minikube \u003ccommand\u003e --help\" for more information about a given command. ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:1:3","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"简单使用 minikube ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:2:0","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"启动 Minikube minikube start 在启动的过程中，我遇到了如下错误 ➜ workspace minikube start 😄 Darwin 12.6 (arm64) 上的 minikube v1.30.1 ✨ 自动选择 docker 驱动 📌 Using Docker Desktop driver with root privileges 👍 Starting control plane node minikube in cluster minikube 🚜 Pulling base image ... 💾 Downloading Kubernetes v1.26.3 preload ... \u003e preloaded-images-k8s-v18-v1...: 330.52 MiB / 330.52 MiB 100.00% 6.16 Mi \u003e index.docker.io/kicbase/sta...: 336.39 MiB / 336.39 MiB 100.00% 3.35 Mi ❗ minikube was unable to download gcr.io/k8s-minikube/kicbase:v0.0.39, but successfully downloaded docker.io/kicbase/stable:v0.0.39 as a fallback image 🔥 Creating docker container (CPUs=2, Memory=4000MB) ... ❌ Exiting due to RSRC_DOCKER_STORAGE: Docker is out of disk space! (/var is at 100% of capacity). You can pass '--force' to skip this check. 💡 建议： Try one or more of the following to free up space on the device: 1. Run \"docker system prune\" to remove unused Docker data (optionally with \"-a\") 2. Increase the storage allocated to Docker for Desktop by clicking on: Docker icon \u003e Preferences \u003e Resources \u003e Disk Image Size 3. Run \"minikube ssh -- docker system prune\" if using the Docker container runtime 🍿 Related issue: https://github.com/kubernetes/minikube/issues/9024 解决办法也是按照其提示清理了一下 docker 的数据 docker system prune 万万没想到，这一下直接清理出了 2.561GB 的空间🐶 ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:2:1","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"查看 Minikube 状态 minikube status # 如果是如下输出，说明启动成功 # minikube # type: Control Plane # host: Running # kubelet: Running # apiserver: Running # kubeconfig: Configured ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:2:2","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["DevOps"],"content":"打开 K8S Dashboard minikube dashboard 运行上述命令后，会调起系统的默认浏览器，dashboard UI 如图所示 ","date":"2023-05-29","objectID":"/fufeng/install-k8s-on-mac/:2:3","tags":["K8S","Kubernetes"],"title":"在 Mac 上安装 K8S","uri":"/fufeng/install-k8s-on-mac/"},{"categories":["nodejs"],"content":"一句话答案 主要因为两点，一是 NodeJs 采用了非阻塞异步 I/O 模型，二是 NodeJs 是基于事件驱动的编程模型。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:1:0","tags":["node.js"],"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":["nodejs"],"content":"详细解答 Node.js 是单线程的，采用了非阻塞异步 I/O 模型，可以在等待 I/O 操作（如读取文件、网络请求等）时让 CPU 去做其他工作，等数据返回后再去执行回调函数。这样可以充分利用 CPU 的时间，提高处理 I/O 密集型任务的效率。 Node.js 基于事件驱动的编程模型，通过注册事件监听器来处理请求。当有请求到来时，Node.js 会把请求交给事件循环处理，等待响应后再把结果返回。这样可以实现高并发、低延迟的服务。同时，事件驱动的编程模型也适用于处理数据流、实现内存占用小等场景。 综上所述，Node.js 适合处理高并发、响应时间短、I/O 密集型任务，如 Web 应用中的 HTTP 请求、文件读写、数据库操作等。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:2:0","tags":["node.js"],"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":["nodejs"],"content":"NodeJs 如何实现事件驱动的异步 I/O 模型？ NodeJs 通过 libuv 库实现非阻塞异步 I/O 模型。libuv 为 NodeJs 提供了统一的 I/O 接口，抹平了不同操作系统之间的 I/O 操作差异。下图是 libuv 的架构图： libuv 的事件循环 libuv 的核心是事件循环，事件循环采用单线程异步I/O的方法：所有（网络）I/O都在非阻塞的套接字上执行，由操作系统提供最佳机制进行轮询：Linux上的epoll、OSX和其他BSD上的kqueue、SunOS上的事件端口和Windows上的IOCP。在循环迭代的一部分中，循环将阻塞等待已添加到轮询器中的套接字上的I/O活动，并触发回调以指示套接字状态（可读、可写、挂起），以便句柄可以执行所需的读取、写入或I/O操作。下图展示了事件循环的各个阶段： 在每轮事件循环迭代开始之前，NodeJs 会缓存当前时间，用于后续判断定时器是否到达执行时间。如果事件循环仍然存活着，那么开始进入事件循环，否则结束循环，杀掉线程。 事件循环的第一个阶段是 Run due timers 阶段（定时器阶段），用于执行已经到期的定时器回调函数，即通过 setTimeout 或者 setInterval 函数注册的回调函数。 事件循环的第二个阶段是 Call pending callbacks 阶段，这个阶段是执行在上个迭代中没有执行完毕的 I/O 回调函数 事件循环的第三个阶段是 Run idle handles 阶段，这个阶段执行 nodejs 内部注册的回调函数 事件循环的第四个阶段是 Run prepare handles 阶段，本阶段执行 nodejs 内部注册的回调函数，用于准备即将启动的Poll for I/O阶段。它的主要作用是在执行轮询阶段之前运行一些准备工作，例如打开或关闭某些资源，初始化或重置一些状态等。 事件循环的第五个阶段是 Poll for I/O 阶段, 在这个阶段会阻塞等待操作系统的 I/O 操作，如果有写/读操作完成，则会在这个时候调用相关的回调函数。这个阶段的阻塞等待时长是按照如下规则计算的： 如果事件循环使用 UV_RUN_NOWAIT 标志运行，则等待时长为 0 如果事件循环正在被中止(uv_stop函数被调用)，则等待时长为 0 如果没有活动的句柄或请求(没有打开文件描述符且没有 socket 连接)，则等待时长为 0 如果有 idle handles 存在，则等待时长为 0 如果有句柄正在等待关闭，则等待时长为 0 如果上述情况都不符合，则取最接近的定时器的超时时间；如果没有注册定时器，则等待时长为无限（直到某个 I/O 操作完成） 事件循环的第六个阶段是 Run check handles 阶段，这个阶段执行 setImmediate 注册的回调函数 事件循环的第七个阶段是 Call close callbacks 阶段，所有 close 事件注册的回调函数在这个阶段执行 nodejs 的完整事件循环 nodejs 在 libuv 的事件循环的基础上增加了两个任务队列，分别是 nextTick 和 promise 微任务队列。完整的 nodejs 事件循环可参考图： 这两个任务队列并非在 libuv 中被执行，它们都是在 nodejs 层执行的，在 libuv 层处理每一个阶段的任务之后，会和 node 层进行通讯，那么会优先处理两个队列中的任务。注意： 这两个任务队列的执行会阻塞 libuv 的事件循环 nextTick 任务的优先级要大于 Microtasks 任务中的 Promise 回调。也就是说 node 会首先清空 nextTick 中的任务，然后才是 Promise 中的任务。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:2:1","tags":["node.js"],"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":["nodejs"],"content":"参考文档 libuv 1.45.1-dev documentation » Design overview 「Nodejs万字进阶」一文吃透异步I/O和事件循环 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:3:0","tags":["node.js"],"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":["os"],"content":"起因 老婆使用的电脑系统（Windows 10）坏了，会一直卡在登录页面，登录成功之后又返回登录页面，陷入死循环。 于是，修好电脑的重担就落在了笔者的头上。 笔者脑子一热，直接装了一个 Ubuntu 系统（装机过程省略，网上很多教程），然后又吭哧吭哧地安装了微信和QQ，但是用起来非常不得劲，微信还好，除了UI偏小没啥大问题，但是 QQ 就丑爆了~ 迫不得已，只好重新安装 Windows 系统，磨难正式开始~~ ","date":"2023-04-20","objectID":"/fufeng/install-os/:1:0","tags":["操作系统","linux"],"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":["os"],"content":"磨难 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:0","tags":["操作系统","linux"],"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":["os"],"content":"制作装机 U 盘 以前有过制作装机 U 盘的经历，不过是使用了大白菜（大白菜官网），然而大白菜支持在 Windows 系统上制作装机 U 盘，本人的 Windows 电脑已经坏了，工作电脑是 Mac，所以大白菜就没法使用了。 之前安装 Ubuntu 系统，是使用 Etcher 制作装机 U 盘。但是制作的 Windows 系统装机 U 盘是无法正常使用的，在尝试从 U 盘启动系统时，也无法正常启动。 然后尝试了使用命令行工具制作装机 U 盘，命令如下： diskutil eraseDisk FAT32 \"WINDOWS10\" MBR disk4 cp -rpv /Volumes/CCHA_X64FREO_ZH-CN_DV9/* /Volumes/WINDOWS10 但是在安装的时候提示 install.win 损坏。经过查询，原来是 FAT32 格式的文件系统无法存储单个大于 4GB 的文件，导致 install.win 文件损坏了。 解决办法 第一步，分割一下 Windows 镜像，使其能够完整的写入 FAT32 格式的 U 盘中，分割的方式是使用 Boot Camp ISO Converter，下载地址如下图所示 第二步，格式化 U 盘 # disk4 需要替换成 U 盘的盘符，可以使用命令 diskutil list 查看 diskutil eraseDisk FAT32 \"WINDOWS10\" MBR disk4 第三步，双击下载的 Windows 镜像，使其在 Mac 上挂载，此时可以通过 diskutil list 查看对应的盘符 第四步，通过 CP 命令拷贝镜像到 U 盘中 cp -rpv /Volumes/CCHA_X64FREO_ZH-CN_DV9/* /Volumes/WINDOWS10 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:1","tags":["操作系统","linux"],"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":["os"],"content":"硬盘分区和格式化 制作完装机 U 盘后，在装机时遇到另一个问题： Windows 系统只能安装在 NTFS 的文件系统中。而在安装 Ubuntu 系统时，电脑硬盘已经格式化成了 EXT3 的文件系统，所以需要重新格式化硬盘。然后就遭遇了各种格式化硬盘的打击： 格式化时提示硬盘使用中 umount 时提示umount: target is busy 解决办法 第一步，使用 Unetbootin 制作 Gparted 启动盘 Unetbootin 下载地址： unetbootin Gparted 镜像下载地址： gparted 第二步，使用第一步制作的 Gparted 启动盘格式化硬盘和分区 这里建议分区后再格式化，这样可以不影响原本的 Ubuntu 系统，也就是可以双系统。具体步骤可以参考 gparted 教程 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:2","tags":["操作系统","linux"],"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":["os"],"content":"参考 知乎: 2021年mac系统下制作win10引导安装盘，亲测可用 [详细教程] 在现有Ubuntu系统上安装Windows 10 （双系统） ","date":"2023-04-20","objectID":"/fufeng/install-os/:3:0","tags":["操作系统","linux"],"title":"记一次装机过程","uri":"/fufeng/install-os/"}]