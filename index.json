[{"categories":null,"content":"一句话答案 主要因为两点，一是 NodeJs 采用了非阻塞异步 I/O 模型，二是 NodeJs 是基于事件驱动的编程模型。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:1:0","tags":null,"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":null,"content":"详细解答 Node.js 是单线程的，采用了非阻塞异步 I/O 模型，可以在等待 I/O 操作（如读取文件、网络请求等）时让 CPU 去做其他工作，等数据返回后再去执行回调函数。这样可以充分利用 CPU 的时间，提高处理 I/O 密集型任务的效率。 Node.js 基于事件驱动的编程模型，通过注册事件监听器来处理请求。当有请求到来时，Node.js 会把请求交给事件循环处理，等待响应后再把结果返回。这样可以实现高并发、低延迟的服务。同时，事件驱动的编程模型也适用于处理数据流、实现内存占用小等场景。 综上所述，Node.js 适合处理高并发、响应时间短、I/O 密集型任务，如 Web 应用中的 HTTP 请求、文件读写、数据库操作等。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:2:0","tags":null,"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":null,"content":"NodeJs 如何实现事件驱动的异步 I/O 模型？ NodeJs 通过 libuv 库实现非阻塞异步 I/O 模型。libuv 为 NodeJs 提供了统一的 I/O 接口，抹平了不同操作系统之间的 I/O 操作差异。下图是 libuv 的架构图： libuv 的事件循环 libuv 的核心是事件循环，事件循环采用单线程异步I/O的方法：所有（网络）I/O都在非阻塞的套接字上执行，由操作系统提供最佳机制进行轮询：Linux上的epoll、OSX和其他BSD上的kqueue、SunOS上的事件端口和Windows上的IOCP。在循环迭代的一部分中，循环将阻塞等待已添加到轮询器中的套接字上的I/O活动，并触发回调以指示套接字状态（可读、可写、挂起），以便句柄可以执行所需的读取、写入或I/O操作。下图展示了事件循环的各个阶段： 在每轮事件循环迭代开始之前，NodeJs 会缓存当前时间，用于后续判断定时器是否到达执行时间。如果事件循环仍然存活着，那么开始进入事件循环，否则结束循环，杀掉线程。 事件循环的第一个阶段是 Run due timers 阶段（定时器阶段），用于执行已经到期的定时器回调函数，即通过 setTimeout 或者 setInterval 函数注册的回调函数。 事件循环的第二个阶段是 Call pending callbacks 阶段，这个阶段是执行在上个迭代中没有执行完毕的 I/O 回调函数 事件循环的第三个阶段是 Run idle handles 阶段，这个阶段执行 nodejs 内部注册的回调函数 事件循环的第四个阶段是 Run prepare handles 阶段，本阶段执行 nodejs 内部注册的回调函数，用于准备即将启动的Poll for I/O阶段。它的主要作用是在执行轮询阶段之前运行一些准备工作，例如打开或关闭某些资源，初始化或重置一些状态等。 事件循环的第五个阶段是 Poll for I/O 阶段, 在这个阶段会阻塞等待操作系统的 I/O 操作，如果有写/读操作完成，则会在这个时候调用相关的回调函数。这个阶段的阻塞等待时长是按照如下规则计算的： 如果事件循环使用 UV_RUN_NOWAIT 标志运行，则等待时长为 0 如果事件循环正在被中止(uv_stop函数被调用)，则等待时长为 0 如果没有活动的句柄或请求(没有打开文件描述符且没有 socket 连接)，则等待时长为 0 如果有 idle handles 存在，则等待时长为 0 如果有句柄正在等待关闭，则等待时长为 0 如果上述情况都不符合，则取最接近的定时器的超时时间；如果没有注册定时器，则等待时长为无限（直到某个 I/O 操作完成） 事件循环的第六个阶段是 Run check handles 阶段，这个阶段执行 setImmediate 注册的回调函数 事件循环的第七个阶段是 Call close callbacks 阶段，所有 close 事件注册的回调函数在这个阶段执行 nodejs 的完整事件循环 nodejs 在 libuv 的事件循环的基础上增加了两个任务队列，分别是 nextTick 和 promise 微任务队列。完整的 nodejs 事件循环可参考图： 这两个任务队列并非在 libuv 中被执行，它们都是在 nodejs 层执行的，在 libuv 层处理每一个阶段的任务之后，会和 node 层进行通讯，那么会优先处理两个队列中的任务。注意： 这两个任务队列的执行会阻塞 libuv 的事件循环 nextTick 任务的优先级要大于 Microtasks 任务中的 Promise 回调。也就是说 node 会首先清空 nextTick 中的任务，然后才是 Promise 中的任务。 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:2:1","tags":null,"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":null,"content":"参考文档 libuv 1.45.1-dev documentation » Design overview 「Nodejs万字进阶」一文吃透异步I/O和事件循环 ","date":"2023-05-09","objectID":"/fufeng/nodejs-01/:3:0","tags":null,"title":"为什么说 NodeJs 适合 I/O 密集型系统？","uri":"/fufeng/nodejs-01/"},{"categories":null,"content":"起因 老婆使用的电脑系统（Windows 10）坏了，会一直卡在登录页面，登录成功之后又返回登录页面，陷入死循环。 于是，修好电脑的重担就落在了笔者的头上。 笔者脑子一热，直接装了一个 Ubuntu 系统（装机过程省略，网上很多教程），然后又吭哧吭哧地安装了微信和QQ，但是用起来非常不得劲，微信还好，除了UI偏小没啥大问题，但是 QQ 就丑爆了~ 迫不得已，只好重新安装 Windows 系统，磨难正式开始~~ ","date":"2023-04-20","objectID":"/fufeng/install-os/:1:0","tags":null,"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":null,"content":"磨难 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:0","tags":null,"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":null,"content":"制作装机 U 盘 以前有过制作装机 U 盘的经历，不过是使用了大白菜（大白菜官网），然而大白菜支持在 Windows 系统上制作装机 U 盘，本人的 Windows 电脑已经坏了，工作电脑是 Mac，所以大白菜就没法使用了。 之前安装 Ubuntu 系统，是使用 Etcher 制作装机 U 盘。但是制作的 Windows 系统装机 U 盘是无法正常使用的，在尝试从 U 盘启动系统时，也无法正常启动。 然后尝试了使用命令行工具制作装机 U 盘，命令如下： diskutil eraseDisk FAT32 \"WINDOWS10\" MBR disk4 cp -rpv /Volumes/CCHA_X64FREO_ZH-CN_DV9/* /Volumes/WINDOWS10 但是在安装的时候提示 install.win 损坏。经过查询，原来是 FAT32 格式的文件系统无法存储单个大于 4GB 的文件，导致 install.win 文件损坏了。 解决办法 第一步，分割一下 Windows 镜像，使其能够完整的写入 FAT32 格式的 U 盘中，分割的方式是使用 Boot Camp ISO Converter，下载地址如下图所示 第二步，格式化 U 盘 # disk4 需要替换成 U 盘的盘符，可以使用命令 diskutil list 查看 diskutil eraseDisk FAT32 \"WINDOWS10\" MBR disk4 第三步，双击下载的 Windows 镜像，使其在 Mac 上挂载，此时可以通过 diskutil list 查看对应的盘符 第四步，通过 CP 命令拷贝镜像到 U 盘中 cp -rpv /Volumes/CCHA_X64FREO_ZH-CN_DV9/* /Volumes/WINDOWS10 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:1","tags":null,"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":null,"content":"硬盘分区和格式化 制作完装机 U 盘后，在装机时遇到另一个问题： Windows 系统只能安装在 NTFS 的文件系统中。而在安装 Ubuntu 系统时，电脑硬盘已经格式化成了 EXT3 的文件系统，所以需要重新格式化硬盘。然后就遭遇了各种格式化硬盘的打击： 格式化时提示硬盘使用中 umount 时提示umount: target is busy 解决办法 第一步，使用 Unetbootin 制作 Gparted 启动盘 Unetbootin 下载地址： unetbootin Gparted 镜像下载地址： gparted 第二步，使用第一步制作的 Gparted 启动盘格式化硬盘和分区 这里建议分区后再格式化，这样可以不影响原本的 Ubuntu 系统，也就是可以双系统。具体步骤可以参考 gparted 教程 ","date":"2023-04-20","objectID":"/fufeng/install-os/:2:2","tags":null,"title":"记一次装机过程","uri":"/fufeng/install-os/"},{"categories":null,"content":"参考 知乎: 2021年mac系统下制作win10引导安装盘，亲测可用 [详细教程] 在现有Ubuntu系统上安装Windows 10 （双系统） ","date":"2023-04-20","objectID":"/fufeng/install-os/:3:0","tags":null,"title":"记一次装机过程","uri":"/fufeng/install-os/"}]